#!/usr/bin/perl

sub print_help {
  print <<'HELP';

ff_gen_charge_constr - Generate charge constraint equations for force field fitting

USAGE:
    ff_gen_charge_constr COU_terms constraint_equation

DESCRIPTION:
    Generates charge constraint equations for CRYOFF force field optimization by
    mapping charge product pairs to constraint indices and processing constraint
    equation definitions.

ARGUMENTS:
    COU_terms          File containing Coulomb charge product pairs (atom type pairs)
    constraint_equation File defining constraint equations and atomic charges

INPUT FILE FORMATS:

    COU_terms file (two-column format):
        atm1  atm2
        C     H
        O     H
        N     C
        ...

        - Lists atom type pairs for charge products
        - Order-independent (C H = H C)
        - Each pair assigned sequential index number

    constraint_equation file:
        coeff1 atom1 + coeff2 atom2 + ... + coeffN atomN = scaling_factor
        weight
        atomX  [charge_X]
        atomY  [charge_Y]
        ...

        Line 1: Neutrality/constraint equation in algebraic format
                Format: coeff1 atom1 + coeff2 atom2 + ... = scaling_factor
                Coefficients are number of each atom type in molecule
                Scaling factor: multiply atom charges by this (use 0 for neutrality)
        Line 2: Weight for this constraint equation
        Lines 3+: Atom types to apply constraint to, with optional charges
                Format: atomname [charge]
                If charge omitted, defaults to 0
                Each atom listed generates one constraint equation

OUTPUT FORMAT:
    ncharge num1 index1 num2 index2 ... constraint_value weight

    - ncharge: Number of charge products in equation
    - num1, num2, ...: Coefficients from the neutrality equation
    - index1, index2, ...: Indices from COU_terms mapping
    - constraint_value: atom_charge × scaling_factor
    - weight: Weight for constraint equation
    - Errors with missing pairs sent to stderr with "_not_found_" marker

HOW IT WORKS:
    For each atom listed in lines 3+, generates a constraint equation:
    Σ(coeff_i × q_atom × q_i) = atom_charge × scaling_factor

    Where q_atom is the charge of the listed atom and q_i are charges
    of atoms in the equation.

USE CASES:
    1. Neutrality constraints (scaling_factor = 0, no charges):
       Enforces charge neutrality: 1 O0 + 1 C1 + 2 C2 + ... = 0
       Each atom type listed must satisfy the neutrality equation

    2. Charge relationship constraints (with charges):
       Enforces specific interaction energies between atoms
       Useful for fitting to QM-derived charge distributions

EXAMPLE 1 - Neutrality Constraint:
    # Create COU terms
    cat > cou_terms.dat << EOF
    C1  C1
    C1  O0
    C1  H1
    O0  O0
    O0  H1
    H1  H1
    EOF

    # Neutrality constraint equation
    cat > constraint.dat << EOF
    1 O0 + 1 C1 + 2 C2 + 1 C3 + 1 H0 + 9 H1 = 0
    1E5
    O0
    C1
    H0
    EOF

    # Generate neutrality constraints
    ff_gen_charge_constr cou_terms.dat constraint.dat > constraints.out

EXAMPLE 2 - Charge Relationship Constraint:
    # With specific charges and scaling
    cat > constraint_charged.dat << EOF
    1 O0 + 1 C1 + 2 C2 = 2.5
    1.0
    O0  -0.6645
    C1   0.1234
    EOF

    # This creates constraints with values:
    # O0: -0.6645 × 2.5 = -1.66125
    # C1:  0.1234 × 2.5 =  0.3085
    ff_gen_charge_constr cou_terms.dat constraint_charged.dat > constraints.out

INTEGRATION:
    - Enforces physical relationships between charge products
    - Maintains charge neutrality during CRYOFF optimization
    - Supports fitting to QM-derived electrostatic properties
    - Compatible with CRYOFF force field optimization workflow
    - Essential for adaptive force matching with polarizable force fields

HELP
  exit;
}

if( $ARGV[0] eq '-h' || $ARGV[0] eq '-help' || @ARGV < 2)
{
  print_help();
}

$QQpair=$ARGV[0];shift;$equation=$ARGV[0];

#COU terms
open (QQ,$QQpair);
$index=0;
while(<QQ>) { chomp;
  ($atm1,$atm2)=split;
  $pair=$atm1." ".$atm2;
  $pair=$atm2." ".$atm1 if ($atm2 lt $atm1);
  $QQindex{$pair}= ++$index;
}

open(EQ,$equation);
do{ $_=<EQ> }while substr($_, 0, 1) eq "#"; @equ=split;
$ncharge=(@equ-1)/3;
die "please check input line.$_.\n" unless ($ncharge == int($ncharge));
print "# Eq.: ".$_;
$_=<EQ>;chomp; $weight=$_; #read in weight

while(<EQ>)
{
next if  substr($_, 0, 1) eq "#";
($atm2,$atmc)=split; #atom name $atm2 and atom charge $atmc

$buf="$ncharge ";
for ($i=0;$i<$ncharge;$i++){
$num=$equ[$i*3]; $atm1=$equ[$i*3+1];
$pair=$atm1." ".$atm2;
$pair=$atm2." ".$atm1 if ($atm2 lt $atm1);
if ($QQindex{$pair}){
$buf = $buf.$num." ".$QQindex{$pair}." " ;}
else {
$buf = $buf.$num." _not_found_ " ; }
}
if ($buf =~ /_not_found_/) {
print STDERR $buf,$atmc*$equ[-1]," $weight\n";}
else{
print $buf,$atmc*$equ[-1]," $weight\n";}
}

